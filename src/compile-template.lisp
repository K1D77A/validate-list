(in-package #:validate-list)
(defparameter *test-template9-expanded* '((:EQUAL "year") (:TYPE INTEGER :OR (96 97 98))
                                          ((:OR ("cookie" "country"))
                                           ((:TYPE STRING :MAXLEN 6 :MINLEN 2)
                                            (:TYPE NUMBER :BETWEEN (0 100))
                                            (:TYPE STRING :MAXLEN 6 :MINLEN 2)
                                            (:TYPE NUMBER :BETWEEN (0 100))
                                            (:TYPE STRING :MAXLEN 6 :MINLEN 2)
                                            (:TYPE NUMBER :BETWEEN (0 100))))
                                          ((:TYPE NUMBER :SATISFIES (#'EVENP #'ODDP))
                                           (:TYPE NUMBER :SATISFIES (#'EVENP #'ODDP))
                                           (:TYPE NUMBER :SATISFIES (#'EVENP #'ODDP)))))
(defparameter *test1* '("year"))
(defparameter *temp1* '((:type string :equal "year")))
(defparameter *test1-compiled* (lambda (list)
                                 (let ((first (first list)))
                                   (progn (and (funcall #'handle-type first 'string)
                                               (funcall #'handle-equal first "year"))))))

(defparameter *test2* '("year" 2000))
(defparameter *temp2* '((:type string :equal "year")
                        (:type integer :between (1900 2100))))

(defparameter *test3* '("year" 2000 ("anyway" "boof") "beef"))
(defparameter *temp3* '((:type string :equal "year")
                        (:type integer :between (1900 2100))
                        ((:type string :equal "anyway")
                         (:type string :equal "boof"))
                        (:type string :equal "beef")))



(defparameter *test2-compiled*
  `(lambda (list)
     (handler-case 
         (let ((first (first list)))
           ,(compile-template-entry (first *temp2*) 'first)
           (let ((second (second list)))
             ,(compile-template-entry (second *temp2*) 'second)))
       (failed-to-validate () nil))))

(defun pop-through-all (list)
  (let ((temp list))
    (labels ((rec (list)
               (let ((popped (pop list)))
                 (cond ((null popped)
                        nil)
                       ((listp popped)
                        (cons (rec popped)
                              (rec list)))
                       (t 
                        (rec list))))))
      (rec temp))))

(defun describe-template-structure (template)
  (let ((res))
    (labels ((tmp (list)
               (mapcar (lambda (entry)
                         (if (listp (first entry))
                             (progn (push 'list res)
                                    (tmp entry))
                             (push 'pop res)))
                       list)
               (push 'end res)))
      (tmp template))
    (reverse res)))

(defparameter *t* '(progn
                    (let ((first (pop list)))
                      (validate))
                    (let ((second (pop list)))
                      (validate))
                    (let ((nlist (pop list)))
                      (let (first (pop nlist))
                        (validate))
                      (let (first (pop nlist))
                        (validate))
                      (let ((nlist2 (pop nlist)))
                        (let ((first (pop nlist2)))
                          (validate))))
                    (let ((first (pop list))))))

(defun compile-template (template)
  `(lambda (list)
     (handler-case 
         ,(labels ((rec (list acc)
                     (format t "list: ~A~%" list)
                     (cond ((null list)
                            acc)
                           
                           ((and (listp (first list))
                                 (keywordp (first (first list))))
                            (let ((tmp (gensym)))
                              (rec (rest list) `(let ((,tmp (pop list)))
                                                  ,(compile-template-entry
                                                    (first list) tmp)
                                                  ,acc))))
                           ((listp (first (first list)))
                            `(let ((x (pop list)))
                               ,(rec (first list) acc)))
                           ((listp list)
                            (rec (first list) acc)
                            (rec (rest list) acc)))))
            
            (rec template nil))
       (failed-to-validate () nil))))


(defun compile-template-entry (template-entry var)
  `(progn ,@(map-plist (lambda (key val)
                         `(call-fun-check-true ,(keyword->function key) ,var ',val))
                       template-entry)))

(defun call-fun-check-true (fun arg1 arg2)
  (if (funcall fun arg1 arg2)
      t
      (signal-failed-to-validate fun arg2 arg1 (format nil "failed to validate calling ~A" fun))))
